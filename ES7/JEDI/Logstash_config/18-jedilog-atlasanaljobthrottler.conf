filter {
  if ([@metadata][beat] == "jedilogs") {
    if ([fields][type] == "atlasanaljobthrottler") {

      fingerprint {
        concatenate_all_fields => true
        target => "uid"
      }

      if [event][original] and ![message] {
        mutate { copy => { "[event][original]" => "message" } }
      }

      mutate {
        rename => { "message" => "garbage" }
      }

      ruby {
        code => 'event.set("garbage", event.get("garbage").to_s.split.join(" "))'
      }

      grok {
        patterns_dir => "/usr/share/logstash/patterns/"
        match => {
          "garbage" => [
            "^%{TIMESTAMP_ISO8601:timeEvent}\s+%{DATA:logName}:\s+%{WORD:logLevel}\s+<(?<timestamp_atlasanaljobthrottler>\d{4}-\d{2}-\d{2}/\d{2}:\d{2}:\d{2}\.\d{6})>\s+%{GREEDYDATA:message}$"
          ]
        }
      }

      date {
        timezone => "Etc/UTC"
        match => ["timeEvent", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss,SSS"]
        target => "@timestamp"
      }

      if ("_grokparsefailure" not in [tags]) {

        mutate { remove_field => "garbage" }

        grok {
          match => {
            "message" => [
              "^atlas:%{WORD:atlas}\s+cloud=%{DATA:cloud}\s+queue=%{DATA:queue}\s+resource_type=%{DATA:resource_type}:\s*%{GREEDYDATA:rt_message}$"
            ]
          }
          tag_on_failure => []
        }

        mutate {
          gsub => [ "resource_type", ":$", "" ]
        }

        if [rt_message] =~ "^(PASS|SKIP|FAIL|OK|WARN|WARNING|ERROR)\b" {
          grok {
            match => {
              "rt_message" => [
                "^(?<decision>PASS|SKIP|FAIL|OK|WARN|WARNING|ERROR)\s+%{GREEDYDATA:rt_details}$"
              ]
            }
            tag_on_failure => []
          }
        } else if [rt_message] {
          mutate { copy => { "rt_message" => "rt_details" } }
        }

        if [rt_details] {
          grok {
            match => { "rt_details" => [ "GS_throttled\s+is\s+%{WORD:GS_throttled}" ] }
            tag_on_failure => []
          }
        }

        if [rt_details] =~ "at resource type level:" {
          grok {
            match => { "rt_details" => [ "at resource type level:\s+%{GREEDYDATA:kv_message}$" ] }
            tag_on_failure => []
          }
          kv {
            source => "kv_message"
            field_split_pattern => "\s+"
            value_split => "="
            trim_key => " \t"
            trim_value => " \t"
          }
        } else if [rt_details] =~ "=" and [rt_details] !~ "\(" {
          kv {
            source => "rt_details"
            field_split_pattern => "\s+"
            value_split => "="
            trim_key => " \t"
            trim_value => " \t"
          }
        }

        mutate {
          remove_field => [ "rt_message", "rt_details", "kv_message" ]
        }
      }

      ruby {
        code => "
          event.to_hash.each do |key,value|
            if value.instance_of? String
              if (value.match(/^(\\d+[,.]\\d+)/))
                value = value.gsub(',','.')
                event.set(key, value.to_f)
              end
              if (value.match(/^(\\d)+$/))
                event.set(key, value.to_i)
              end
            end
          end
        "
      }
    }
  }
}