filter {
  if ([@metadata][beat] == "jedilogs") {
    if ([fields][type] == "atlasanaljobthrottler") {

     fingerprint {
        concatenate_all_fields => true
        target => "uid"
      }

      if [event][original] {
        mutate { copy => { "[event][original]" => "message" } }
      }

      mutate { rename => { "message" => "garbage" } }

      ruby { code => 'event.set("garbage", event.get("garbage").to_s.split.join(" "))' }

      grok {
        patterns_dir => "/usr/share/logstash/patterns/"
        match => {
          "garbage" => [
            "^%{TIMESTAMP_ISO8601:timeEvent}\s+%{DATA:logName}:\s+%{WORD:logLevel}\s+<(?<timestamp_atlasprodjobthrottler>\d{4}-\d{2}-\d{2}/\d{2}:\d{2}:\d{2}\.\d{6})>\s+%{GREEDYDATA:message}$"
          ]
        }
      }

      date {
        timezone => "Etc/UTC"
        match => ["timeEvent", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss,SSS"]
        target => "@timestamp"
      }

      if ("_grokparsefailure" not in [tags]) {

        mutate { remove_field => "garbage" }

        grok {
          match => {
            "message" => [
              "^atlas:%{DATA:atlas}\s+cloud=%{DATA:cloud}\s+queue=%{DATA:queue}\s+resource_type=%{DATA:resource_type}:\s*%{GREEDYDATA:rt_message}$"
            ]
          }
          tag_on_failure => []
        }

        mutate { gsub => [ "resource_type", ":$", "" ] }

        if [rt_message] =~ "^(PASS|SKIP|FAIL|OK|WARN|WARNING|ERROR)\b" {
          grok {
            match => { "rt_message" => [ "^(?<decision>PASS|SKIP|FAIL|OK|WARN|WARNING|ERROR)\s+%{GREEDYDATA:rt_details}$" ] }
            tag_on_failure => []
          }
        } else if [rt_message] {
          mutate { copy => { "rt_message" => "rt_details" } }
        }

        if [rt_details] {
          grok {
            match => { "rt_details" => [ "GS_throttled\s+is\s+%{WORD:GS_throttled}" ] }
            tag_on_failure => []
          }
        }

        if [rt_details] =~ "^at resource type level:" {
          grok { match => { "rt_details" => [ "^at resource type level:\s+%{GREEDYDATA:kv_message}$" ] } tag_on_failure => [] }
          kv { source => "kv_message" field_split_pattern => "\s+" value_split => "=" trim_key => " \t" trim_value => " \t" }
        } else if [rt_details] =~ "^at global share level:" {
          grok { match => { "rt_details" => [ "^at global share level:\s+%{GREEDYDATA:kv_message}$" ] } tag_on_failure => [] }
          kv { source => "kv_message" field_split_pattern => "\s+" value_split => "=" trim_key => " \t" trim_value => " \t" }
        } else if [rt_details] =~ "^at MCORE/SCORE level:" {
          grok { match => { "rt_details" => [ "^at MCORE/SCORE level:\s+%{GREEDYDATA:kv_message}$" ] } tag_on_failure => [] }
          kv { source => "kv_message" field_split_pattern => "\s+" value_split => "=" trim_key => " \t" trim_value => " \t" }
        } else if [rt_details] =~ "^\s*nQueueLimit=" {
          kv { source => "rt_details" field_split_pattern => "\s+" value_split => "=" trim_key => " \t" trim_value => " \t" }
        } else if [rt_details] =~ "=" and [rt_details] !~ "\(" {
          kv { source => "rt_details" field_split_pattern => "\s+" value_split => "=" trim_key => " \t" trim_value => " \t" }
        }

        if [decision] == "SKIP" {
          grok {
            match => {
              "rt_details" => [
                "nQueued_rt\(%{INT:nQueued_rt}\)/nRunning_rt\(%{INT:nRunning_rt}\)>%{NUMBER:queued_running_ratio}.*nQueued_queuelimit=%{INT:nQueued_queuelimit}>\(NQUEUELIMIT_%{DATA:nqueuelimit_name}=%{INT:nQueueLimit_from_msg}\).*totWalltime\(%{INT:totWalltime}\)>%{INT:totWalltime_limit}"
              ]
            }
            add_tag => ["_skip_grok_ok"]
            tag_on_failure => ["_skip_grok_fail"]
          }

          if "_skip_grok_fail" in [tags] {
            kv {
              source => "rt_details"
              field_split_pattern => "\s+"
              value_split => "="
              trim_key => " \t"
              trim_value => " \t"
            }
            mutate { remove_tag => ["_skip_grok_fail"] }
          }

          mutate { remove_tag => ["_skip_grok_ok"] }
        }

        mutate { remove_field => [ "rt_message", "rt_details", "kv_message" ] }
      }

      ruby {
        code => "
          event.to_hash.each do |key,value|
            if value.instance_of? String
              if (value.match(/^(\\d+[,.]\\d+)/))
                value = value.gsub(',','.')
                event.set(key, value.to_f)
              end
              if (value.match(/^(\\d)+$/))
                event.set(key, value.to_i)
              end
            end
          end
        "
      }
    }
  }
}