filter {
	if ([@metadata][beat]=="harvestertitanlogs")
	{
		if ([fields][type]=="harvester_watcher")
		{
			mutate {
				rename => {"message"=>"garbage"}
			}
			ruby {
				code => '
				event.set("garbage", event.get("garbage").split.join(" "))'
			}
			grok {
				patterns_dir => "/usr/share/logstash/patterns/"
				match => { "garbage" => ["%{TIMESTAMP_ISO8601:timeEvent} %{TYPE:logName}: %{WORD:logLevel} %{WORD:type} <queue=%{GREEDYDATA:site}> %{GREEDYDATA:message}",
				"%{TIMESTAMP_ISO8601:timeEvent} %{TYPE:logName}: %{WORD:logLevel} %{WORD:type} %{GREEDYDATA:message}"]
				}
			}
			ruby {
				code => "
						event.to_hash.each do |key,value|
						if key == 'message'
						event.set('memconsumption', value.scan(/[-+]?\d+[\.]?\d*[eE]?[-+]?\d*/).last)
						end
						end"
			}
			date {
				timezone => "Etc/UTC"
				match => ["timeEvent", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS"]
				target => "@timestamp"
				remove_field => [ "timeEvent"]
			}
			ruby {
				code => "
						event.to_hash.each do |key,value|
						if value.instance_of? String
							if (value.match(/^(\d+[,.]\d+)/))
								value = value.gsub(',','.')
								event.set(key, value.to_f)
							end
							if (value.match(/^(\d)+$/))
								event.set(key, value.to_i)
							end
						end
						end"
			}
			if ("_grokparsefailure" not in [tags])
			{
				mutate {
					remove_field => "garbage"
				}
			}
		}
	}
}
